<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Connectivity Tester</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #18191a;
            color: #e4e6eb;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
        }

        .container {
            background-color: #242526;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1000px;
            text-align: center;
        }

        h1 {
            margin-top: 0;
            color: #e4e6eb;
        }

        .input-group {
            margin-bottom: 1rem;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #404040;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
            background-color: #3a3b3c;
            color: #e4e6eb;
        }

        button {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 6px;
            background-color: #1877f2;
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #166fe5;
        }

        .home-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem 1rem;
            background-color: #3a3b3c;
            color: #e4e6eb;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            border: 1px solid #404040;
            transition: background-color 0.2s;
        }

        .home-button:hover {
            background-color: #4e4f50;
            text-decoration: none;
        }

        #results {
            margin-top: 1.5rem;
            text-align: left;
        }

        .scan-section {
            margin-bottom: 2rem;
            padding: 1rem;
            background-color: #3a3b3c;
            border: 1px solid #404040;
            border-radius: 6px;
        }

        .scan-section h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #e4e6eb;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .port-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .port-item {
            background-color: #2a2b2c;
            padding: 0.75rem;
            border-radius: 4px;
            border-left: 3px solid #404040;
            transition: border-color 0.3s;
        }

        .port-item.open {
            border-left-color: #4caf50;
        }

        .port-item.closed {
            border-left-color: #f44336;
        }

        .port-item.filtered {
            border-left-color: #ff9800;
        }

        .port-item.unknown {
            border-left-color: #9e9e9e;
        }

        .port-item.accessible {
            border-left-color: #4caf50;
        }

        .port-item.unreachable {
            border-left-color: #f44336;
        }

        .port-item.browser-limitation {
            border-left-color: #9e9e9e;
        }

        .port-item.scanning {
            border-left-color: #2196f3;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .port-number {
            font-weight: bold;
            font-size: 1.1rem;
            color: #e4e6eb;
        }

        .port-service {
            font-size: 0.9rem;
            color: #8a8b8c;
            margin: 0.25rem 0;
        }

        .port-status {
            font-size: 0.8rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            display: inline-block;
            margin-top: 0.25rem;
        }

        .status-open {
            background-color: #2e4a2f;
            color: #6aba6e;
        }

        .status-closed {
            background-color: #5a2a2a;
            color: #ff8a80;
        }

        .status-filtered {
            background-color: #5a4a2a;
            color: #ffb74d;
        }

        .status-unknown {
            background-color: #4a4a4a;
            color: #9e9e9e;
        }

        .status-accessible {
            background-color: #2e4a2f;
            color: #6aba6e;
        }

        .status-unreachable {
            background-color: #5a2a2a;
            color: #ff8a80;
        }

        .status-browser-limitation {
            background-color: #4a4a4a;
            color: #9e9e9e;
        }

        .status-scanning {
            background-color: #2a4a5a;
            color: #64b5f6;
        }

        .loading {
            text-align: center;
            color: #8a8b8c;
            font-style: italic;
            padding: 2rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #404040;
            border-radius: 3px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #1877f2;
            transition: width 0.3s ease;
            width: 0%;
        }

        .summary {
            background-color: #3a3b3c;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .summary h3 {
            margin-top: 0;
            color: #e4e6eb;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .summary-item {
            text-align: center;
            padding: 1rem;
            background-color: #2a2b2c;
            border-radius: 4px;
        }

        .summary-count {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .count-open {
            color: #4caf50;
        }

        .count-closed {
            color: #f44336;
        }

        .count-filtered {
            color: #ff9800;
        }

        .count-unknown {
            color: #9e9e9e;
        }

        .count-total {
            color: #2196f3;
        }

        .warning {
            background-color: #5a4a2a;
            color: #ffb74d;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            border-left: 4px solid #ff9800;
        }

        .scan-time {
            font-size: 0.9rem;
            color: #8a8b8c;
            margin-top: 0.5rem;
        }
    </style>
</head>

<body>
    <a href="index.html" class="home-button">‚Üê Home</a>
    <div class="container">
        <h1>Network Connectivity Tester</h1>
        <div class="warning">
            <strong>Network Connectivity Tester:</strong> This tool tests network connectivity across multiple protocols
            (TCP, UDP, ICMP) using various methods. Results show exactly which protocols succeeded, matching how
            firewalls control access. Note: Direct ICMP ping and raw UDP sockets are limited in browsers, but we use
            alternative detection methods.
        </div>
        <div class="input-group">
            <label for="target">Target Host</label>
            <input type="text" id="target" placeholder="e.g., example.com or 192.168.1.1">
        </div>
        <button id="scanButton">Test Network Connectivity</button>
        <div id="results"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const targetInput = document.getElementById('target');
            const scanButton = document.getElementById('scanButton');
            const resultsDiv = document.getElementById('results');

            // Common ports to scan with their services
            const COMMON_PORTS = [
                // Web Services
                { port: 80, service: 'HTTP', protocol: 'tcp', category: 'Web' },
                { port: 443, service: 'HTTPS', protocol: 'tcp', category: 'Web' },
                { port: 8080, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8443, service: 'HTTPS Alt', protocol: 'tcp', category: 'Web' },
                { port: 8000, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8008, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8888, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 9000, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 9090, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 3000, service: 'Node.js/React Dev', protocol: 'tcp', category: 'Web' },
                { port: 4200, service: 'Angular Dev', protocol: 'tcp', category: 'Web' },
                { port: 5000, service: 'Flask/Python Dev', protocol: 'tcp', category: 'Web' },
                { port: 8081, service: 'HTTP Proxy', protocol: 'tcp', category: 'Web' },
                { port: 8082, service: 'HTTP Proxy', protocol: 'tcp', category: 'Web' },

                // Mail Services
                { port: 25, service: 'SMTP', protocol: 'tcp', category: 'Mail' },
                { port: 587, service: 'SMTP (Submission)', protocol: 'tcp', category: 'Mail' },
                { port: 465, service: 'SMTPS', protocol: 'tcp', category: 'Mail' },
                { port: 110, service: 'POP3', protocol: 'tcp', category: 'Mail' },
                { port: 995, service: 'POP3S', protocol: 'tcp', category: 'Mail' },
                { port: 143, service: 'IMAP', protocol: 'tcp', category: 'Mail' },
                { port: 993, service: 'IMAPS', protocol: 'tcp', category: 'Mail' },
                { port: 2525, service: 'SMTP Alt', protocol: 'tcp', category: 'Mail' },

                // Remote Access
                { port: 22, service: 'SSH', protocol: 'tcp', category: 'Remote' },
                { port: 23, service: 'Telnet', protocol: 'tcp', category: 'Remote' },
                { port: 3389, service: 'RDP', protocol: 'tcp', category: 'Remote' },
                { port: 5900, service: 'VNC', protocol: 'tcp', category: 'Remote' },
                { port: 5901, service: 'VNC Alt', protocol: 'tcp', category: 'Remote' },
                { port: 5902, service: 'VNC Alt', protocol: 'tcp', category: 'Remote' },
                { port: 5985, service: 'WinRM HTTP', protocol: 'tcp', category: 'Remote' },
                { port: 5986, service: 'WinRM HTTPS', protocol: 'tcp', category: 'Remote' },
                { port: 2222, service: 'SSH Alt', protocol: 'tcp', category: 'Remote' },
                { port: 2022, service: 'SSH Alt', protocol: 'tcp', category: 'Remote' },

                // File Transfer
                { port: 21, service: 'FTP', protocol: 'tcp', category: 'File Transfer' },
                { port: 22, service: 'SFTP', protocol: 'tcp', category: 'File Transfer' },
                { port: 69, service: 'TFTP', protocol: 'udp', category: 'File Transfer' },
                { port: 989, service: 'FTPS Data', protocol: 'tcp', category: 'File Transfer' },
                { port: 990, service: 'FTPS Control', protocol: 'tcp', category: 'File Transfer' },
                { port: 2049, service: 'NFS', protocol: 'tcp', category: 'File Transfer' },
                { port: 2049, service: 'NFS', protocol: 'udp', category: 'File Transfer' },

                // DNS & Network
                { port: 53, service: 'DNS', protocol: 'tcp', category: 'DNS' },
                { port: 53, service: 'DNS', protocol: 'udp', category: 'DNS' },
                { port: 853, service: 'DNS over TLS', protocol: 'tcp', category: 'DNS' },
                { port: 5353, service: 'mDNS', protocol: 'udp', category: 'DNS' },

                // Database
                { port: 3306, service: 'MySQL', protocol: 'tcp', category: 'Database' },
                { port: 5432, service: 'PostgreSQL', protocol: 'tcp', category: 'Database' },
                { port: 1433, service: 'MSSQL', protocol: 'tcp', category: 'Database' },
                { port: 1521, service: 'Oracle', protocol: 'tcp', category: 'Database' },
                { port: 27017, service: 'MongoDB', protocol: 'tcp', category: 'Database' },
                { port: 6379, service: 'Redis', protocol: 'tcp', category: 'Database' },
                { port: 5984, service: 'CouchDB', protocol: 'tcp', category: 'Database' },
                { port: 9200, service: 'Elasticsearch', protocol: 'tcp', category: 'Database' },
                { port: 9300, service: 'Elasticsearch', protocol: 'tcp', category: 'Database' },
                { port: 11211, service: 'Memcached', protocol: 'tcp', category: 'Database' },
                { port: 50000, service: 'DB2', protocol: 'tcp', category: 'Database' },

                // System Services
                { port: 135, service: 'RPC Endpoint', protocol: 'tcp', category: 'System' },
                { port: 139, service: 'NetBIOS Session', protocol: 'tcp', category: 'System' },
                { port: 445, service: 'SMB/CIFS', protocol: 'tcp', category: 'System' },
                { port: 161, service: 'SNMP', protocol: 'udp', category: 'System' },
                { port: 162, service: 'SNMP Trap', protocol: 'udp', category: 'System' },
                { port: 137, service: 'NetBIOS Name', protocol: 'udp', category: 'System' },
                { port: 138, service: 'NetBIOS Datagram', protocol: 'udp', category: 'System' },
                { port: 389, service: 'LDAP', protocol: 'tcp', category: 'System' },
                { port: 636, service: 'LDAPS', protocol: 'tcp', category: 'System' },
                { port: 88, service: 'Kerberos', protocol: 'tcp', category: 'System' },
                { port: 88, service: 'Kerberos', protocol: 'udp', category: 'System' },

                // Application Services
                { port: 6000, service: 'X11', protocol: 'tcp', category: 'Application' },
                { port: 6001, service: 'X11 Alt', protocol: 'tcp', category: 'Application' },
                { port: 7000, service: 'Cassandra', protocol: 'tcp', category: 'Application' },
                { port: 7001, service: 'Cassandra SSL', protocol: 'tcp', category: 'Application' },
                { port: 9042, service: 'Cassandra CQL', protocol: 'tcp', category: 'Application' },
                { port: 2181, service: 'Zookeeper', protocol: 'tcp', category: 'Application' },
                { port: 9092, service: 'Kafka', protocol: 'tcp', category: 'Application' },
                { port: 5672, service: 'RabbitMQ', protocol: 'tcp', category: 'Application' },
                { port: 15672, service: 'RabbitMQ Management', protocol: 'tcp', category: 'Application' },
                { port: 4369, service: 'Erlang Port Mapper', protocol: 'tcp', category: 'Application' },

                // Proxy & Load Balancer
                { port: 3128, service: 'Squid Proxy', protocol: 'tcp', category: 'Proxy' },
                { port: 8118, service: 'Privoxy', protocol: 'tcp', category: 'Proxy' },
                { port: 1080, service: 'SOCKS Proxy', protocol: 'tcp', category: 'Proxy' },
                { port: 9050, service: 'Tor SOCKS', protocol: 'tcp', category: 'Proxy' },
                { port: 80, service: 'HAProxy Stats', protocol: 'tcp', category: 'Proxy' },
                { port: 8404, service: 'HAProxy Stats', protocol: 'tcp', category: 'Proxy' },

                // Monitoring & Management
                { port: 9090, service: 'Prometheus', protocol: 'tcp', category: 'Monitoring' },
                { port: 3000, service: 'Grafana', protocol: 'tcp', category: 'Monitoring' },
                { port: 9093, service: 'Alertmanager', protocol: 'tcp', category: 'Monitoring' },
                { port: 9100, service: 'Node Exporter', protocol: 'tcp', category: 'Monitoring' },
                { port: 8086, service: 'InfluxDB', protocol: 'tcp', category: 'Monitoring' },
                { port: 5601, service: 'Kibana', protocol: 'tcp', category: 'Monitoring' },
                { port: 4040, service: 'Spark UI', protocol: 'tcp', category: 'Monitoring' },

                // Container & Orchestration
                { port: 2375, service: 'Docker API', protocol: 'tcp', category: 'Container' },
                { port: 2376, service: 'Docker API TLS', protocol: 'tcp', category: 'Container' },
                { port: 2377, service: 'Docker Swarm', protocol: 'tcp', category: 'Container' },
                { port: 6443, service: 'Kubernetes API', protocol: 'tcp', category: 'Container' },
                { port: 10250, service: 'Kubelet API', protocol: 'tcp', category: 'Container' },
                { port: 10255, service: 'Kubelet Read-only', protocol: 'tcp', category: 'Container' },
                { port: 8001, service: 'Kubernetes Proxy', protocol: 'tcp', category: 'Container' },

                // Gaming & Entertainment
                { port: 25565, service: 'Minecraft', protocol: 'tcp', category: 'Gaming' },
                { port: 27015, service: 'Steam/Source', protocol: 'tcp', category: 'Gaming' },
                { port: 7777, service: 'Game Server', protocol: 'tcp', category: 'Gaming' },
                { port: 7777, service: 'Game Server', protocol: 'udp', category: 'Gaming' },
                { port: 1935, service: 'RTMP (Streaming)', protocol: 'tcp', category: 'Gaming' },

                // Security & VPN
                { port: 1194, service: 'OpenVPN', protocol: 'udp', category: 'Security' },
                { port: 1723, service: 'PPTP VPN', protocol: 'tcp', category: 'Security' },
                { port: 500, service: 'IPSec IKE', protocol: 'udp', category: 'Security' },
                { port: 4500, service: 'IPSec NAT-T', protocol: 'udp', category: 'Security' },
                { port: 1812, service: 'RADIUS Auth', protocol: 'udp', category: 'Security' },
                { port: 1813, service: 'RADIUS Accounting', protocol: 'udp', category: 'Security' },

                // IoT & Embedded
                { port: 1883, service: 'MQTT', protocol: 'tcp', category: 'IoT' },
                { port: 8883, service: 'MQTT over SSL', protocol: 'tcp', category: 'IoT' },
                { port: 5683, service: 'CoAP', protocol: 'udp', category: 'IoT' },
                { port: 5684, service: 'CoAP over DTLS', protocol: 'udp', category: 'IoT' },
                { port: 502, service: 'Modbus', protocol: 'tcp', category: 'IoT' },

                // Legacy & Misc
                { port: 79, service: 'Finger', protocol: 'tcp', category: 'Legacy' },
                { port: 70, service: 'Gopher', protocol: 'tcp', category: 'Legacy' },
                { port: 119, service: 'NNTP', protocol: 'tcp', category: 'Legacy' },
                { port: 563, service: 'NNTPS', protocol: 'tcp', category: 'Legacy' },
                { port: 194, service: 'IRC', protocol: 'tcp', category: 'Legacy' },
                { port: 6667, service: 'IRC', protocol: 'tcp', category: 'Legacy' },
                { port: 6697, service: 'IRC SSL', protocol: 'tcp', category: 'Legacy' },
                { port: 513, service: 'rlogin', protocol: 'tcp', category: 'Legacy' },
                { port: 514, service: 'rsh', protocol: 'tcp', category: 'Legacy' },
                { port: 515, service: 'LPD/LPR', protocol: 'tcp', category: 'Legacy' },
                { port: 631, service: 'IPP/CUPS', protocol: 'tcp', category: 'Legacy' },

                // High Ports & Services
                { port: 49152, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 32768, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 32769, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 65535, service: 'Highest Port', protocol: 'tcp', category: 'High Ports' }
            ];

            // Remove duplicates and create unique port list
            const uniquePorts = COMMON_PORTS.reduce((acc, current) => {
                const key = `${current.port}-${current.protocol}`;
                if (!acc.find(item => `${item.port}-${item.protocol}` === key)) {
                    acc.push(current);
                }
                return acc;
            }, []);

            const testConnectivity = async (host, port, expectedProtocol, timeout = 4000) => {
                return new Promise((resolve) => {
                    const startTime = Date.now();

                    if (expectedProtocol === 'udp') {
                        // UDP testing is very limited from browsers
                        tests.push({
                            name: 'UDP-Probe',
                            protocol: 'UDP',
                            test: () => {
                                return new Promise((udpResolve) => {
                                    // Try to create a fake UDP "connection" via fetch to a likely UDP service
                                    const controller = new AbortController();
                                    const timeoutId = setTimeout(() => controller.abort(), 1000);

                                    // For DNS port 53, try a DNS-over-HTTPS query as proxy
                                    if (port === 53) {
                                        fetch(`https://${host}/dns-query?name=test.com&type=A`, {
                                            method: 'GET',
                                            mode: 'no-cors',
                                            signal: controller.signal
                                        }).then(() => {
                                            clearTimeout(timeoutId);
                                            udpResolve({
                                                success: true,
                                                protocol: 'UDP',
                                                method: 'UDP-Probe',
                                                details: 'UDP DNS service likely accessible (via DoH proxy test)'
                                            });
                                        }).catch(() => {
                                            clearTimeout(timeoutId);
                                            udpResolve({
                                                success: false,
                                                protocol: 'UDP',
                                                method: 'UDP-Probe',
                                                details: 'UDP DNS service test failed (browser limitation)'
                                            });
                                        });
                                    } else {
                                        // For other UDP ports, we can't really test them
                                        setTimeout(() => {
                                            udpResolve({
                                                success: false,
                                                protocol: 'UDP',
                                                method: 'UDP-Probe',
                                                details: 'UDP connectivity cannot be directly tested from browsers (security restriction)'
                                            });
                                        }, 100);
                                    }
                                });
                            }
                        });
                    }

                    const tests = [];

                    // ICMP Ping Test (using image loading as proxy)
                    tests.push({
                        name: 'ICMP-Ping',
                        protocol: 'ICMPv4',
                        test: () => {
                            return new Promise((pingResolve) => {
                                const img = new Image();
                                const timeoutId = setTimeout(() => {
                                    img.src = '';
                                    pingResolve({
                                        success: false,
                                        protocol: 'ICMPv4',
                                        method: 'ICMP-Ping',
                                        details: 'ICMP ping timeout (host may be down or ICMP blocked)'
                                    });
                                }, 1000);

                                img.onload = () => {
                                    clearTimeout(timeoutId);
                                    pingResolve({
                                        success: true,
                                        protocol: 'ICMPv4',
                                        method: 'ICMP-Ping',
                                        details: 'Host responding to ICMP (via HTTP image request)'
                                    });
                                };

                                img.onerror = () => {
                                    clearTimeout(timeoutId);
                                    const responseTime = Date.now() - startTime;
                                    if (responseTime < 50) {
                                        pingResolve({
                                            success: false,
                                            protocol: 'ICMPv4',
                                            method: 'ICMP-Ping',
                                            details: 'Host unreachable (ICMP blocked or host down)'
                                        });
                                    } else {
                                        pingResolve({
                                            success: true,
                                            protocol: 'ICMPv4',
                                            method: 'ICMP-Ping',
                                            details: 'Host reachable (ICMP allowed, HTTP service may be down)'
                                        });
                                    }
                                };

                                // Try to ping via a simple image request
                                img.src = `http://${host}/favicon.ico?ping=${Date.now()}`;
                            });
                        }
                    });

                    // HTTP GET Test
                    if (port === 80 || port === 8000 || port === 8008 || port === 8080 || port === 8081 || port === 8082 || port === 8888 || port === 9000 || port === 9090 || port === 3000 || port === 5000 || port === 4200) {
                        tests.push({
                            name: 'HTTP-GET',
                            protocol: 'TCP',
                            test: () => {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 2000);

                                return fetch(`http://${host}:${port}/`, {
                                    method: 'GET',
                                    mode: 'no-cors',
                                    signal: controller.signal,
                                    cache: 'no-cache',
                                    headers: { 'User-Agent': 'NetworkConnectivityTester/1.0' }
                                }).then((response) => {
                                    clearTimeout(timeoutId);
                                    return {
                                        success: true,
                                        protocol: 'TCP',
                                        method: 'HTTP-GET',
                                        details: `TCP connection successful via HTTP GET (status: ${response.status || 'opaque'})`
                                    };
                                }).catch((error) => {
                                    clearTimeout(timeoutId);
                                    if (error.name === 'AbortError') {
                                        return { success: false, protocol: 'TCP', method: 'HTTP-GET', details: 'TCP connection timeout' };
                                    }
                                    if (error.message.includes('CORS') || error.message.includes('network')) {
                                        return {
                                            success: true,
                                            protocol: 'TCP',
                                            method: 'HTTP-GET',
                                            details: 'TCP connection successful (CORS blocked, but service accessible)'
                                        };
                                    }
                                    return { success: false, protocol: 'TCP', method: 'HTTP-GET', details: `TCP connection failed: ${error.message}` };
                                });
                            }
                        });

                        // HTTP POST Test
                        tests.push({
                            name: 'HTTP-POST',
                            protocol: 'TCP',
                            test: () => {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 2000);

                                return fetch(`http://${host}:${port}/`, {
                                    method: 'POST',
                                    mode: 'no-cors',
                                    signal: controller.signal,
                                    cache: 'no-cache',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'User-Agent': 'NetworkConnectivityTester/1.0'
                                    },
                                    body: JSON.stringify({ test: 'connectivity' })
                                }).then((response) => {
                                    clearTimeout(timeoutId);
                                    return {
                                        success: true,
                                        protocol: 'TCP',
                                        method: 'HTTP-POST',
                                        details: `TCP connection successful via HTTP POST (status: ${response.status || 'opaque'})`
                                    };
                                }).catch((error) => {
                                    clearTimeout(timeoutId);
                                    if (error.name === 'AbortError') {
                                        return { success: false, protocol: 'TCP', method: 'HTTP-POST', details: 'TCP connection timeout' };
                                    }
                                    if (error.message.includes('CORS') || error.message.includes('network')) {
                                        return {
                                            success: true,
                                            protocol: 'TCP',
                                            method: 'HTTP-POST',
                                            details: 'TCP connection successful (CORS blocked, but service accessible)'
                                        };
                                    }
                                    return { success: false, protocol: 'TCP', method: 'HTTP-POST', details: `TCP connection failed: ${error.message}` };
                                });
                            }
                        });
                    }

                    // HTTPS GET Test
                    if (port === 443 || port === 8443 || port === 8000 || port === 3000 || port === 5000 || port === 4200 || port === 9000) {
                        tests.push({
                            name: 'HTTPS-GET',
                            protocol: 'TCP+TLS',
                            test: () => {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 2000);

                                return fetch(`https://${host}:${port}/`, {
                                    method: 'GET',
                                    mode: 'no-cors',
                                    signal: controller.signal,
                                    cache: 'no-cache',
                                    headers: { 'User-Agent': 'NetworkConnectivityTester/1.0' }
                                }).then((response) => {
                                    clearTimeout(timeoutId);
                                    return {
                                        success: true,
                                        protocol: 'TCP+TLS',
                                        method: 'HTTPS-GET',
                                        details: `TCP+TLS connection successful via HTTPS GET (status: ${response.status || 'opaque'})`
                                    };
                                }).catch((error) => {
                                    clearTimeout(timeoutId);
                                    if (error.name === 'AbortError') {
                                        return { success: false, protocol: 'TCP+TLS', method: 'HTTPS-GET', details: 'TCP+TLS connection timeout' };
                                    }
                                    if (error.message.includes('CORS') || error.message.includes('network')) {
                                        return {
                                            success: true,
                                            protocol: 'TCP+TLS',
                                            method: 'HTTPS-GET',
                                            details: 'TCP+TLS connection successful (CORS blocked, but service accessible)'
                                        };
                                    }
                                    return { success: false, protocol: 'TCP+TLS', method: 'HTTPS-GET', details: `TCP+TLS connection failed: ${error.message}` };
                                });
                            }
                        });

                        // HTTPS POST Test
                        tests.push({
                            name: 'HTTPS-POST',
                            protocol: 'TCP+TLS',
                            test: () => {
                                const controller = new AbortController();
                                const timeoutId = setTimeout(() => controller.abort(), 2000);

                                return fetch(`https://${host}:${port}/`, {
                                    method: 'POST',
                                    mode: 'no-cors',
                                    signal: controller.signal,
                                    cache: 'no-cache',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'User-Agent': 'NetworkConnectivityTester/1.0'
                                    },
                                    body: JSON.stringify({ test: 'connectivity' })
                                }).then((response) => {
                                    clearTimeout(timeoutId);
                                    return {
                                        success: true,
                                        protocol: 'TCP+TLS',
                                        method: 'HTTPS-POST',
                                        details: `TCP+TLS connection successful via HTTPS POST (status: ${response.status || 'opaque'})`
                                    };
                                }).catch((error) => {
                                    clearTimeout(timeoutId);
                                    if (error.name === 'AbortError') {
                                        return { success: false, protocol: 'TCP+TLS', method: 'HTTPS-POST', details: 'TCP+TLS connection timeout' };
                                    }
                                    if (error.message.includes('CORS') || error.message.includes('network')) {
                                        return {
                                            success: true,
                                            protocol: 'TCP+TLS',
                                            method: 'HTTPS-POST',
                                            details: 'TCP+TLS connection successful (CORS blocked, but service accessible)'
                                        };
                                    }
                                    return { success: false, protocol: 'TCP+TLS', method: 'HTTPS-POST', details: `TCP+TLS connection failed: ${error.message}` };
                                });
                            }
                        });
                    }

                    // WebSocket Test (TCP-based)
                    tests.push({
                        name: 'WebSocket',
                        protocol: 'TCP',
                        test: () => {
                            return new Promise((wsResolve) => {
                                try {
                                    const ws = new WebSocket(`ws://${host}:${port}`);
                                    let resolved = false;

                                    const timeoutId = setTimeout(() => {
                                        if (!resolved) {
                                            resolved = true;
                                            ws.close();
                                            wsResolve({
                                                success: false,
                                                protocol: 'TCP',
                                                method: 'WebSocket',
                                                details: 'TCP connection timeout via WebSocket'
                                            });
                                        }
                                    }, 1500);

                                    ws.onopen = () => {
                                        if (!resolved) {
                                            resolved = true;
                                            clearTimeout(timeoutId);
                                            ws.close();
                                            wsResolve({
                                                success: true,
                                                protocol: 'TCP',
                                                method: 'WebSocket',
                                                details: 'TCP connection successful via WebSocket protocol'
                                            });
                                        }
                                    };

                                    ws.onerror = () => {
                                        if (!resolved) {
                                            resolved = true;
                                            clearTimeout(timeoutId);
                                            const responseTime = Date.now() - startTime;
                                            wsResolve({
                                                success: false,
                                                protocol: 'TCP',
                                                method: 'WebSocket',
                                                details: responseTime < 100 ? 'TCP connection refused (port closed)' : 'TCP connection failed (filtered/blocked)'
                                            });
                                        }
                                    };

                                    ws.onclose = (event) => {
                                        if (!resolved) {
                                            resolved = true;
                                            clearTimeout(timeoutId);
                                            const responseTime = Date.now() - startTime;
                                            if (responseTime < 200 && event.code === 1006) {
                                                wsResolve({
                                                    success: true,
                                                    protocol: 'TCP',
                                                    method: 'WebSocket',
                                                    details: 'TCP connection established (service doesn\'t speak WebSocket protocol)'
                                                });
                                            } else {
                                                wsResolve({
                                                    success: false,
                                                    protocol: 'TCP',
                                                    method: 'WebSocket',
                                                    details: `TCP connection closed (WebSocket code: ${event.code})`
                                                });
                                            }
                                        }
                                    };
                                } catch (error) {
                                    wsResolve({
                                        success: false,
                                        protocol: 'TCP',
                                        method: 'WebSocket',
                                        details: `TCP connection error via WebSocket: ${error.message}`
                                    });
                                }
                            });
                        }
                    });

                    // Resource Loading Test (HTTP-based)
                    tests.push({
                        name: 'Resource-Load',
                        protocol: 'TCP',
                        test: () => {
                            return new Promise((imgResolve) => {
                                const img = new Image();
                                const timeoutId = setTimeout(() => {
                                    img.src = '';
                                    imgResolve({
                                        success: false,
                                        protocol: 'TCP',
                                        method: 'Resource-Load',
                                        details: 'TCP connection timeout during resource loading'
                                    });
                                }, 2000);

                                img.onload = () => {
                                    clearTimeout(timeoutId);
                                    imgResolve({
                                        success: true,
                                        protocol: 'TCP',
                                        method: 'Resource-Load',
                                        details: 'TCP connection successful via HTTP resource loading (favicon.ico)'
                                    });
                                };

                                img.onerror = () => {
                                    clearTimeout(timeoutId);
                                    const responseTime = Date.now() - startTime;
                                    if (responseTime < 100) {
                                        imgResolve({
                                            success: false,
                                            protocol: 'TCP',
                                            method: 'Resource-Load',
                                            details: 'TCP connection refused (port closed)'
                                        });
                                    } else {
                                        imgResolve({
                                            success: true,
                                            protocol: 'TCP',
                                            method: 'Resource-Load',
                                            details: 'TCP connection successful via HTTP (404/403 for favicon, but service is running)'
                                        });
                                    }
                                };

                                img.src = `http://${host}:${port}/favicon.ico?t=${Date.now()}`;
                            });
                        }
                    });

                    // Run all tests concurrently
                    Promise.allSettled(tests.map(test => test.test())).then(testResults => {
                        const responseTime = Date.now() - startTime;

                        // Analyze results
                        const successfulTests = testResults
                            .filter(result => result.status === 'fulfilled' && result.value.success)
                            .map(result => result.value);

                        const failedTests = testResults
                            .filter(result => result.status === 'fulfilled' && !result.value.success)
                            .map(result => result.value);

                        const workingProtocols = [...new Set(successfulTests.map(test => test.protocol))];

                        let status = 'unreachable';
                        let primaryMethod = 'none';
                        let details = 'No connectivity detected';

                        if (successfulTests.length > 0) {
                            status = 'accessible';
                            primaryMethod = successfulTests[0].method;
                            details = `Service accessible via ${workingProtocols.join(', ')}`;
                        } else if (failedTests.some(test => test.details.includes('timeout'))) {
                            status = 'filtered';
                            details = 'Connection attempts timed out (likely filtered by firewall)';
                        } else {
                            status = 'closed';
                            details = 'Connection refused (port closed or service not running)';
                        }

                        resolve({
                            port,
                            expectedProtocol,
                            status,
                            responseTime,
                            workingProtocols,
                            primaryMethod,
                            details,
                            allResults: [...successfulTests, ...failedTests]
                        });
                    });
                });
            };

            const createPortItem = (portInfo, status = 'scanning') => {
                const item = document.createElement('div');
                item.className = `port-item ${status}`;
                item.id = `port-${portInfo.port}-${portInfo.protocol}`;

                item.innerHTML = `
        <div class="port-number">${portInfo.port}/${portInfo.protocol.toUpperCase()}</div>
        <div class="port-service">${portInfo.service}</div>
        <div class="port-status status-${status}">${status.toUpperCase()}</div>
        `;

                return item;
            };

            const updatePortItem = (portInfo, result) => {
                const item = document.getElementById(`port-${portInfo.port}-${portInfo.protocol}`);
                if (item) {
                    item.className = `port-item ${result.status}`;
                    const statusElement = item.querySelector('.port-status');
                    statusElement.className = `port-status status-${result.status}`;

                    let statusText = `${result.status.toUpperCase()} (${result.responseTime}ms)`;
                    if (result.workingProtocols && result.workingProtocols.length > 0) {
                        statusText = `${result.status.toUpperCase()} via ${result.workingProtocols.join(', ')} (${result.responseTime}ms)`;
                    }

                    statusElement.textContent = statusText;

                    let tooltipText = `Status: ${result.status}\n`;
                    tooltipText += `Primary Method: ${result.primaryMethod}\n`;
                    tooltipText += `Details: ${result.details}\n`;
                    if (result.workingProtocols && result.workingProtocols.length > 0) {
                        tooltipText += `Working Protocols: ${result.workingProtocols.join(', ')}\n`;
                    }
                    if (result.allResults && result.allResults.length > 0) {
                        tooltipText += `\nAll Test Results:\n`;
                        result.allResults.forEach(test => {
                            tooltipText += `- ${test.method} (${test.protocol}): ${test.success ? 'SUCCESS' : 'FAILED'} - ${test.details}\n`;
                        });
                    }

                    statusElement.title = tooltipText;
                }
            };

            const createSummary = (results, host, scanTime) => {
                const summary = document.createElement('div');
                summary.className = 'summary';

                const title = document.createElement('h3');
                title.textContent = `Port Scan Results for ${host}`;
                summary.appendChild(title);

                const scanTimeDiv = document.createElement('div');
                scanTimeDiv.className = 'scan-time';
                scanTimeDiv.textContent = `Scan completed in ${(scanTime / 1000).toFixed(2)} seconds`;
                summary.appendChild(scanTimeDiv);

                const grid = document.createElement('div');
                grid.className = 'summary-grid';

                // Count results
                const counts = {
                    total: results.length,
                    accessible: results.filter(r => r.status === 'accessible').length,
                    unreachable: results.filter(r => r.status === 'unreachable').length,
                    closed: results.filter(r => r.status === 'closed').length,
                    filtered: results.filter(r => r.status === 'filtered').length,
                    'browser-limitation': results.filter(r => r.status === 'browser-limitation').length
                };

                // Create summary items
                Object.entries(counts).forEach(([status, count]) => {
                    const item = document.createElement('div');
                    item.className = 'summary-item';
                    item.innerHTML = `
        <div class="summary-count count-${status}">${count}</div>
        <div>${status.charAt(0).toUpperCase() + status.slice(1)} Ports</div>
        `;
                    grid.appendChild(item);
                });

                summary.appendChild(grid);
                return summary;
            };

            const updateProgress = (current, total) => {
                const progressBar = document.querySelector('.progress-fill');
                if (progressBar) {
                    const percentage = (current / total) * 100;
                    progressBar.style.width = `${percentage}%`;
                }
            };

            scanButton.addEventListener('click', async () => {
                const target = targetInput.value.trim();

                if (!target) {
                    resultsDiv.innerHTML = '<p style="color: #ff8a80; text-align: center;">Please enter a target host.</p>';
                    return;
                }

                const startTime = Date.now();

                resultsDiv.innerHTML = `
        <div class="loading">
            <p>Scanning ${target}...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <p>Testing ${uniquePorts.length} common ports...</p>
        </div>
        `;

                // Group ports by category
                const categories = {};
                uniquePorts.forEach(port => {
                    if (!categories[port.category]) {
                        categories[port.category] = [];
                    }
                    categories[port.category].push(port);
                });

                // Create sections for each category
                resultsDiv.innerHTML = '';
                const sections = {};

                Object.keys(categories).forEach(category => {
                    const section = document.createElement('div');
                    section.className = 'scan-section';
                    section.innerHTML = `<h3>${category} Services</h3>`;

                    const grid = document.createElement('div');
                    grid.className = 'port-grid';
                    section.appendChild(grid);

                    categories[category].forEach(portInfo => {
                        const portItem = createPortItem(portInfo);
                        grid.appendChild(portItem);
                    });

                    sections[category] = section;
                    resultsDiv.appendChild(section);
                });

                // Add progress bar
                const progressDiv = document.createElement('div');
                progressDiv.innerHTML = `
        <div class="progress-bar">
            <div class="progress-fill"></div>
        </div>
        `;
                resultsDiv.insertBefore(progressDiv, resultsDiv.firstChild);

                // Scan ports
                const results = [];
                const scanPromises = uniquePorts.map(async (portInfo, index) => {
                    const result = await testConnectivity(target, portInfo.port, portInfo.protocol);
                    result.service = portInfo.service;
                    result.category = portInfo.category;
                    results.push(result);

                    updatePortItem(portInfo, result);
                    updateProgress(index + 1, uniquePorts.length);

                    return result;
                });

                try {
                    await Promise.all(scanPromises);

                    const scanTime = Date.now() - startTime;

                    // Remove progress bar
                    progressDiv.remove();

                    // Add summary at the top
                    const summary = createSummary(results, target, scanTime);
                    resultsDiv.insertBefore(summary, resultsDiv.firstChild);

                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: #ff8a80; text-align: center;">Error during scan: ${error.message}</p>`;
                }
            });

            // Allow Enter key to trigger scan
            targetInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    scanButton.click();
                }
            });
        });
    </script>
</body>

</html>