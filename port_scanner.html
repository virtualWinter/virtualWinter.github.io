<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port Scanner</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #18191a;
            color: #e4e6eb;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
        }

        .container {
            background-color: #242526;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1000px;
            text-align: center;
        }

        h1 {
            margin-top: 0;
            color: #e4e6eb;
        }

        .input-group {
            margin-bottom: 1rem;
            text-align: left;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #404040;
            border-radius: 6px;
            font-size: 1rem;
            box-sizing: border-box;
            background-color: #3a3b3c;
            color: #e4e6eb;
        }

        button {
            width: 100%;
            padding: 0.75rem;
            border: none;
            border-radius: 6px;
            background-color: #1877f2;
            color: #fff;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #166fe5;
        }

        .home-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem 1rem;
            background-color: #3a3b3c;
            color: #e4e6eb;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 500;
            border: 1px solid #404040;
            transition: background-color 0.2s;
        }

        .home-button:hover {
            background-color: #4e4f50;
            text-decoration: none;
        }

        #results {
            margin-top: 1.5rem;
            text-align: left;
        }

        .scan-section {
            margin-bottom: 2rem;
            padding: 1rem;
            background-color: #3a3b3c;
            border: 1px solid #404040;
            border-radius: 6px;
        }

        .scan-section h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #e4e6eb;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .port-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .port-item {
            background-color: #2a2b2c;
            padding: 0.75rem;
            border-radius: 4px;
            border-left: 3px solid #404040;
            transition: border-color 0.3s;
        }

        .port-item.open {
            border-left-color: #4caf50;
        }

        .port-item.closed {
            border-left-color: #f44336;
        }

        .port-item.filtered {
            border-left-color: #ff9800;
        }

        .port-item.unknown {
            border-left-color: #9e9e9e;
        }

        .port-item.scanning {
            border-left-color: #2196f3;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .port-number {
            font-weight: bold;
            font-size: 1.1rem;
            color: #e4e6eb;
        }

        .port-service {
            font-size: 0.9rem;
            color: #8a8b8c;
            margin: 0.25rem 0;
        }

        .port-status {
            font-size: 0.8rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            display: inline-block;
            margin-top: 0.25rem;
        }

        .status-open {
            background-color: #2e4a2f;
            color: #6aba6e;
        }

        .status-closed {
            background-color: #5a2a2a;
            color: #ff8a80;
        }

        .status-filtered {
            background-color: #5a4a2a;
            color: #ffb74d;
        }

        .status-unknown {
            background-color: #4a4a4a;
            color: #9e9e9e;
        }

        .status-scanning {
            background-color: #2a4a5a;
            color: #64b5f6;
        }

        .loading {
            text-align: center;
            color: #8a8b8c;
            font-style: italic;
            padding: 2rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #404040;
            border-radius: 3px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background-color: #1877f2;
            transition: width 0.3s ease;
            width: 0%;
        }

        .summary {
            background-color: #3a3b3c;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .summary h3 {
            margin-top: 0;
            color: #e4e6eb;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .summary-item {
            text-align: center;
            padding: 1rem;
            background-color: #2a2b2c;
            border-radius: 4px;
        }

        .summary-count {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .count-open {
            color: #4caf50;
        }

        .count-closed {
            color: #f44336;
        }

        .count-filtered {
            color: #ff9800;
        }

        .count-unknown {
            color: #9e9e9e;
        }

        .count-total {
            color: #2196f3;
        }

        .warning {
            background-color: #5a4a2a;
            color: #ffb74d;
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            border-left: 4px solid #ff9800;
        }

        .scan-time {
            font-size: 0.9rem;
            color: #8a8b8c;
            margin-top: 0.5rem;
        }
    </style>
</head>

<body>
    <a href="index.html" class="home-button">‚Üê Home</a>
    <div class="container">
        <h1>Port Scanner</h1>
        <div class="warning">
            <strong>WebSocket Port Scanner:</strong> This tool uses WebSocket connections to detect open ports. It's
            more reliable than basic HTTP methods but has browser limitations. UDP ports cannot be scanned and will show
            as "unknown". Results may vary due to firewalls and browser security policies.
        </div>
        <div class="input-group">
            <label for="target">Target Host</label>
            <input type="text" id="target" placeholder="e.g., example.com or 192.168.1.1">
        </div>
        <button id="scanButton">Start Port Scan</button>
        <div id="results"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const targetInput = document.getElementById('target');
            const scanButton = document.getElementById('scanButton');
            const resultsDiv = document.getElementById('results');

            // Common ports to scan with their services
            const COMMON_PORTS = [
                // Web Services
                { port: 80, service: 'HTTP', protocol: 'tcp', category: 'Web' },
                { port: 443, service: 'HTTPS', protocol: 'tcp', category: 'Web' },
                { port: 8080, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8443, service: 'HTTPS Alt', protocol: 'tcp', category: 'Web' },
                { port: 8000, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8008, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 8888, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 9000, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 9090, service: 'HTTP Alt', protocol: 'tcp', category: 'Web' },
                { port: 3000, service: 'Node.js/React Dev', protocol: 'tcp', category: 'Web' },
                { port: 4200, service: 'Angular Dev', protocol: 'tcp', category: 'Web' },
                { port: 5000, service: 'Flask/Python Dev', protocol: 'tcp', category: 'Web' },
                { port: 8081, service: 'HTTP Proxy', protocol: 'tcp', category: 'Web' },
                { port: 8082, service: 'HTTP Proxy', protocol: 'tcp', category: 'Web' },

                // Mail Services
                { port: 25, service: 'SMTP', protocol: 'tcp', category: 'Mail' },
                { port: 587, service: 'SMTP (Submission)', protocol: 'tcp', category: 'Mail' },
                { port: 465, service: 'SMTPS', protocol: 'tcp', category: 'Mail' },
                { port: 110, service: 'POP3', protocol: 'tcp', category: 'Mail' },
                { port: 995, service: 'POP3S', protocol: 'tcp', category: 'Mail' },
                { port: 143, service: 'IMAP', protocol: 'tcp', category: 'Mail' },
                { port: 993, service: 'IMAPS', protocol: 'tcp', category: 'Mail' },
                { port: 2525, service: 'SMTP Alt', protocol: 'tcp', category: 'Mail' },

                // Remote Access
                { port: 22, service: 'SSH', protocol: 'tcp', category: 'Remote' },
                { port: 23, service: 'Telnet', protocol: 'tcp', category: 'Remote' },
                { port: 3389, service: 'RDP', protocol: 'tcp', category: 'Remote' },
                { port: 5900, service: 'VNC', protocol: 'tcp', category: 'Remote' },
                { port: 5901, service: 'VNC Alt', protocol: 'tcp', category: 'Remote' },
                { port: 5902, service: 'VNC Alt', protocol: 'tcp', category: 'Remote' },
                { port: 5985, service: 'WinRM HTTP', protocol: 'tcp', category: 'Remote' },
                { port: 5986, service: 'WinRM HTTPS', protocol: 'tcp', category: 'Remote' },
                { port: 2222, service: 'SSH Alt', protocol: 'tcp', category: 'Remote' },
                { port: 2022, service: 'SSH Alt', protocol: 'tcp', category: 'Remote' },

                // File Transfer
                { port: 21, service: 'FTP', protocol: 'tcp', category: 'File Transfer' },
                { port: 22, service: 'SFTP', protocol: 'tcp', category: 'File Transfer' },
                { port: 69, service: 'TFTP', protocol: 'udp', category: 'File Transfer' },
                { port: 989, service: 'FTPS Data', protocol: 'tcp', category: 'File Transfer' },
                { port: 990, service: 'FTPS Control', protocol: 'tcp', category: 'File Transfer' },
                { port: 2049, service: 'NFS', protocol: 'tcp', category: 'File Transfer' },
                { port: 2049, service: 'NFS', protocol: 'udp', category: 'File Transfer' },

                // DNS & Network
                { port: 53, service: 'DNS', protocol: 'tcp', category: 'DNS' },
                { port: 53, service: 'DNS', protocol: 'udp', category: 'DNS' },
                { port: 853, service: 'DNS over TLS', protocol: 'tcp', category: 'DNS' },
                { port: 5353, service: 'mDNS', protocol: 'udp', category: 'DNS' },

                // Database
                { port: 3306, service: 'MySQL', protocol: 'tcp', category: 'Database' },
                { port: 5432, service: 'PostgreSQL', protocol: 'tcp', category: 'Database' },
                { port: 1433, service: 'MSSQL', protocol: 'tcp', category: 'Database' },
                { port: 1521, service: 'Oracle', protocol: 'tcp', category: 'Database' },
                { port: 27017, service: 'MongoDB', protocol: 'tcp', category: 'Database' },
                { port: 6379, service: 'Redis', protocol: 'tcp', category: 'Database' },
                { port: 5984, service: 'CouchDB', protocol: 'tcp', category: 'Database' },
                { port: 9200, service: 'Elasticsearch', protocol: 'tcp', category: 'Database' },
                { port: 9300, service: 'Elasticsearch', protocol: 'tcp', category: 'Database' },
                { port: 11211, service: 'Memcached', protocol: 'tcp', category: 'Database' },
                { port: 50000, service: 'DB2', protocol: 'tcp', category: 'Database' },

                // System Services
                { port: 135, service: 'RPC Endpoint', protocol: 'tcp', category: 'System' },
                { port: 139, service: 'NetBIOS Session', protocol: 'tcp', category: 'System' },
                { port: 445, service: 'SMB/CIFS', protocol: 'tcp', category: 'System' },
                { port: 161, service: 'SNMP', protocol: 'udp', category: 'System' },
                { port: 162, service: 'SNMP Trap', protocol: 'udp', category: 'System' },
                { port: 137, service: 'NetBIOS Name', protocol: 'udp', category: 'System' },
                { port: 138, service: 'NetBIOS Datagram', protocol: 'udp', category: 'System' },
                { port: 389, service: 'LDAP', protocol: 'tcp', category: 'System' },
                { port: 636, service: 'LDAPS', protocol: 'tcp', category: 'System' },
                { port: 88, service: 'Kerberos', protocol: 'tcp', category: 'System' },
                { port: 88, service: 'Kerberos', protocol: 'udp', category: 'System' },

                // Application Services
                { port: 6000, service: 'X11', protocol: 'tcp', category: 'Application' },
                { port: 6001, service: 'X11 Alt', protocol: 'tcp', category: 'Application' },
                { port: 7000, service: 'Cassandra', protocol: 'tcp', category: 'Application' },
                { port: 7001, service: 'Cassandra SSL', protocol: 'tcp', category: 'Application' },
                { port: 9042, service: 'Cassandra CQL', protocol: 'tcp', category: 'Application' },
                { port: 2181, service: 'Zookeeper', protocol: 'tcp', category: 'Application' },
                { port: 9092, service: 'Kafka', protocol: 'tcp', category: 'Application' },
                { port: 5672, service: 'RabbitMQ', protocol: 'tcp', category: 'Application' },
                { port: 15672, service: 'RabbitMQ Management', protocol: 'tcp', category: 'Application' },
                { port: 4369, service: 'Erlang Port Mapper', protocol: 'tcp', category: 'Application' },

                // Proxy & Load Balancer
                { port: 3128, service: 'Squid Proxy', protocol: 'tcp', category: 'Proxy' },
                { port: 8118, service: 'Privoxy', protocol: 'tcp', category: 'Proxy' },
                { port: 1080, service: 'SOCKS Proxy', protocol: 'tcp', category: 'Proxy' },
                { port: 9050, service: 'Tor SOCKS', protocol: 'tcp', category: 'Proxy' },
                { port: 80, service: 'HAProxy Stats', protocol: 'tcp', category: 'Proxy' },
                { port: 8404, service: 'HAProxy Stats', protocol: 'tcp', category: 'Proxy' },

                // Monitoring & Management
                { port: 9090, service: 'Prometheus', protocol: 'tcp', category: 'Monitoring' },
                { port: 3000, service: 'Grafana', protocol: 'tcp', category: 'Monitoring' },
                { port: 9093, service: 'Alertmanager', protocol: 'tcp', category: 'Monitoring' },
                { port: 9100, service: 'Node Exporter', protocol: 'tcp', category: 'Monitoring' },
                { port: 8086, service: 'InfluxDB', protocol: 'tcp', category: 'Monitoring' },
                { port: 5601, service: 'Kibana', protocol: 'tcp', category: 'Monitoring' },
                { port: 4040, service: 'Spark UI', protocol: 'tcp', category: 'Monitoring' },

                // Container & Orchestration
                { port: 2375, service: 'Docker API', protocol: 'tcp', category: 'Container' },
                { port: 2376, service: 'Docker API TLS', protocol: 'tcp', category: 'Container' },
                { port: 2377, service: 'Docker Swarm', protocol: 'tcp', category: 'Container' },
                { port: 6443, service: 'Kubernetes API', protocol: 'tcp', category: 'Container' },
                { port: 10250, service: 'Kubelet API', protocol: 'tcp', category: 'Container' },
                { port: 10255, service: 'Kubelet Read-only', protocol: 'tcp', category: 'Container' },
                { port: 8001, service: 'Kubernetes Proxy', protocol: 'tcp', category: 'Container' },

                // Gaming & Entertainment
                { port: 25565, service: 'Minecraft', protocol: 'tcp', category: 'Gaming' },
                { port: 27015, service: 'Steam/Source', protocol: 'tcp', category: 'Gaming' },
                { port: 7777, service: 'Game Server', protocol: 'tcp', category: 'Gaming' },
                { port: 7777, service: 'Game Server', protocol: 'udp', category: 'Gaming' },
                { port: 1935, service: 'RTMP (Streaming)', protocol: 'tcp', category: 'Gaming' },

                // Security & VPN
                { port: 1194, service: 'OpenVPN', protocol: 'udp', category: 'Security' },
                { port: 1723, service: 'PPTP VPN', protocol: 'tcp', category: 'Security' },
                { port: 500, service: 'IPSec IKE', protocol: 'udp', category: 'Security' },
                { port: 4500, service: 'IPSec NAT-T', protocol: 'udp', category: 'Security' },
                { port: 1812, service: 'RADIUS Auth', protocol: 'udp', category: 'Security' },
                { port: 1813, service: 'RADIUS Accounting', protocol: 'udp', category: 'Security' },

                // IoT & Embedded
                { port: 1883, service: 'MQTT', protocol: 'tcp', category: 'IoT' },
                { port: 8883, service: 'MQTT over SSL', protocol: 'tcp', category: 'IoT' },
                { port: 5683, service: 'CoAP', protocol: 'udp', category: 'IoT' },
                { port: 5684, service: 'CoAP over DTLS', protocol: 'udp', category: 'IoT' },
                { port: 502, service: 'Modbus', protocol: 'tcp', category: 'IoT' },

                // Legacy & Misc
                { port: 79, service: 'Finger', protocol: 'tcp', category: 'Legacy' },
                { port: 70, service: 'Gopher', protocol: 'tcp', category: 'Legacy' },
                { port: 119, service: 'NNTP', protocol: 'tcp', category: 'Legacy' },
                { port: 563, service: 'NNTPS', protocol: 'tcp', category: 'Legacy' },
                { port: 194, service: 'IRC', protocol: 'tcp', category: 'Legacy' },
                { port: 6667, service: 'IRC', protocol: 'tcp', category: 'Legacy' },
                { port: 6697, service: 'IRC SSL', protocol: 'tcp', category: 'Legacy' },
                { port: 513, service: 'rlogin', protocol: 'tcp', category: 'Legacy' },
                { port: 514, service: 'rsh', protocol: 'tcp', category: 'Legacy' },
                { port: 515, service: 'LPD/LPR', protocol: 'tcp', category: 'Legacy' },
                { port: 631, service: 'IPP/CUPS', protocol: 'tcp', category: 'Legacy' },

                // High Ports & Services
                { port: 49152, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 32768, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 32769, service: 'Dynamic/Private', protocol: 'tcp', category: 'High Ports' },
                { port: 65535, service: 'Highest Port', protocol: 'tcp', category: 'High Ports' }
            ];

            // Remove duplicates and create unique port list
            const uniquePorts = COMMON_PORTS.reduce((acc, current) => {
                const key = `${current.port}-${current.protocol}`;
                if (!acc.find(item => `${item.port}-${item.protocol}` === key)) {
                    acc.push(current);
                }
                return acc;
            }, []);

            const scanPort = async (host, port, protocol, timeout = 2000) => {
                return new Promise((resolve) => {
                    const startTime = Date.now();

                    if (protocol === 'tcp') {
                        // Primary method: WebSocket connection for all TCP ports
                        const scanWithWebSocket = () => {
                            try {
                                const ws = new WebSocket(`ws://${host}:${port}`);
                                let resolved = false;

                                const timeoutId = setTimeout(() => {
                                    if (!resolved) {
                                        resolved = true;
                                        ws.close();
                                        resolve({
                                            port,
                                            protocol,
                                            status: 'filtered',
                                            responseTime: timeout,
                                            method: 'websocket-timeout'
                                        });
                                    }
                                }, timeout);

                                ws.onopen = () => {
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeoutId);
                                        ws.close();
                                        resolve({
                                            port,
                                            protocol,
                                            status: 'open',
                                            responseTime: Date.now() - startTime,
                                            method: 'websocket-open'
                                        });
                                    }
                                };

                                ws.onerror = (error) => {
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeoutId);

                                        // Analyze the error to determine if port is closed or filtered
                                        const responseTime = Date.now() - startTime;
                                        let status = 'closed';

                                        // Quick response usually means connection refused (closed)
                                        // Slow response or timeout usually means filtered
                                        if (responseTime < 100) {
                                            status = 'closed';
                                        } else if (responseTime >= timeout * 0.8) {
                                            status = 'filtered';
                                        }

                                        resolve({
                                            port,
                                            protocol,
                                            status,
                                            responseTime,
                                            method: 'websocket-error'
                                        });
                                    }
                                };

                                ws.onclose = (event) => {
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeoutId);

                                        // WebSocket closed - could be open port that doesn't speak WebSocket
                                        // or a closed port, analyze the close code and timing
                                        const responseTime = Date.now() - startTime;
                                        let status = 'closed';

                                        if (event.code === 1006 && responseTime < 200) {
                                            // Connection established but immediately closed - likely open port
                                            status = 'open';
                                        } else if (responseTime < 100) {
                                            status = 'closed';
                                        } else {
                                            status = 'filtered';
                                        }

                                        resolve({
                                            port,
                                            protocol,
                                            status,
                                            responseTime,
                                            method: 'websocket-close',
                                            closeCode: event.code
                                        });
                                    }
                                };

                            } catch (error) {
                                resolve({
                                    port,
                                    protocol,
                                    status: 'closed',
                                    responseTime: Date.now() - startTime,
                                    method: 'websocket-exception',
                                    error: error.message
                                });
                            }
                        };

                        // For HTTP/HTTPS ports, try fetch first as fallback, then WebSocket
                        if (port === 80 || port === 8080) {
                            const controller = new AbortController();
                            const fetchTimeoutId = setTimeout(() => controller.abort(), 1000);

                            fetch(`http://${host}:${port}`, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: controller.signal
                            }).then(() => {
                                clearTimeout(fetchTimeoutId);
                                resolve({
                                    port,
                                    protocol,
                                    status: 'open',
                                    responseTime: Date.now() - startTime,
                                    method: 'http-fetch'
                                });
                            }).catch((error) => {
                                clearTimeout(fetchTimeoutId);
                                if (error.name === 'AbortError') {
                                    // Fetch timed out, try WebSocket
                                    scanWithWebSocket();
                                } else {
                                    // Fetch failed, try WebSocket as fallback
                                    scanWithWebSocket();
                                }
                            });
                        } else if (port === 443 || port === 8443) {
                            const controller = new AbortController();
                            const fetchTimeoutId = setTimeout(() => controller.abort(), 1000);

                            fetch(`https://${host}:${port}`, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: controller.signal
                            }).then(() => {
                                clearTimeout(fetchTimeoutId);
                                resolve({
                                    port,
                                    protocol,
                                    status: 'open',
                                    responseTime: Date.now() - startTime,
                                    method: 'https-fetch'
                                });
                            }).catch((error) => {
                                clearTimeout(fetchTimeoutId);
                                if (error.name === 'AbortError') {
                                    // Fetch timed out, try WebSocket
                                    scanWithWebSocket();
                                } else {
                                    // Fetch failed, try WebSocket as fallback
                                    scanWithWebSocket();
                                }
                            });
                        } else {
                            // All other TCP ports use WebSocket directly
                            scanWithWebSocket();
                        }
                    } else {
                        // UDP ports - can't reliably scan from browser
                        setTimeout(() => {
                            resolve({
                                port,
                                protocol,
                                status: 'unknown',
                                responseTime: 50,
                                method: 'udp-unsupported'
                            });
                        }, 50);
                    }
                });
            };

            const createPortItem = (portInfo, status = 'scanning') => {
                const item = document.createElement('div');
                item.className = `port-item ${status}`;
                item.id = `port-${portInfo.port}-${portInfo.protocol}`;

                item.innerHTML = `
        <div class="port-number">${portInfo.port}/${portInfo.protocol.toUpperCase()}</div>
        <div class="port-service">${portInfo.service}</div>
        <div class="port-status status-${status}">${status.toUpperCase()}</div>
        `;

                return item;
            };

            const updatePortItem = (portInfo, result) => {
                const item = document.getElementById(`port-${portInfo.port}-${portInfo.protocol}`);
                if (item) {
                    item.className = `port-item ${result.status}`;
                    const statusElement = item.querySelector('.port-status');
                    statusElement.className = `port-status status-${result.status}`;
                    statusElement.textContent = `${result.status.toUpperCase()} (${result.responseTime}ms)`;
                }
            };

            const createSummary = (results, host, scanTime) => {
                const summary = document.createElement('div');
                summary.className = 'summary';

                const title = document.createElement('h3');
                title.textContent = `Port Scan Results for ${host}`;
                summary.appendChild(title);

                const scanTimeDiv = document.createElement('div');
                scanTimeDiv.className = 'scan-time';
                scanTimeDiv.textContent = `Scan completed in ${(scanTime / 1000).toFixed(2)} seconds`;
                summary.appendChild(scanTimeDiv);

                const grid = document.createElement('div');
                grid.className = 'summary-grid';

                // Count results
                const counts = {
                    total: results.length,
                    open: results.filter(r => r.status === 'open').length,
                    closed: results.filter(r => r.status === 'closed').length,
                    filtered: results.filter(r => r.status === 'filtered').length,
                    unknown: results.filter(r => r.status === 'unknown').length
                };

                // Create summary items
                Object.entries(counts).forEach(([status, count]) => {
                    const item = document.createElement('div');
                    item.className = 'summary-item';
                    item.innerHTML = `
        <div class="summary-count count-${status}">${count}</div>
        <div>${status.charAt(0).toUpperCase() + status.slice(1)} Ports</div>
        `;
                    grid.appendChild(item);
                });

                summary.appendChild(grid);
                return summary;
            };

            const updateProgress = (current, total) => {
                const progressBar = document.querySelector('.progress-fill');
                if (progressBar) {
                    const percentage = (current / total) * 100;
                    progressBar.style.width = `${percentage}%`;
                }
            };

            scanButton.addEventListener('click', async () => {
                const target = targetInput.value.trim();

                if (!target) {
                    resultsDiv.innerHTML = '<p style="color: #ff8a80; text-align: center;">Please enter a target host.</p>';
                    return;
                }

                const startTime = Date.now();

                resultsDiv.innerHTML = `
        <div class="loading">
            <p>Scanning ${target}...</p>
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <p>Testing ${uniquePorts.length} common ports...</p>
        </div>
        `;

                // Group ports by category
                const categories = {};
                uniquePorts.forEach(port => {
                    if (!categories[port.category]) {
                        categories[port.category] = [];
                    }
                    categories[port.category].push(port);
                });

                // Create sections for each category
                resultsDiv.innerHTML = '';
                const sections = {};

                Object.keys(categories).forEach(category => {
                    const section = document.createElement('div');
                    section.className = 'scan-section';
                    section.innerHTML = `<h3>${category} Services</h3>`;

                    const grid = document.createElement('div');
                    grid.className = 'port-grid';
                    section.appendChild(grid);

                    categories[category].forEach(portInfo => {
                        const portItem = createPortItem(portInfo);
                        grid.appendChild(portItem);
                    });

                    sections[category] = section;
                    resultsDiv.appendChild(section);
                });

                // Add progress bar
                const progressDiv = document.createElement('div');
                progressDiv.innerHTML = `
        <div class="progress-bar">
            <div class="progress-fill"></div>
        </div>
        `;
                resultsDiv.insertBefore(progressDiv, resultsDiv.firstChild);

                // Scan ports
                const results = [];
                const scanPromises = uniquePorts.map(async (portInfo, index) => {
                    const result = await scanPort(target, portInfo.port, portInfo.protocol);
                    result.service = portInfo.service;
                    result.category = portInfo.category;
                    results.push(result);

                    updatePortItem(portInfo, result);
                    updateProgress(index + 1, uniquePorts.length);

                    return result;
                });

                try {
                    await Promise.all(scanPromises);

                    const scanTime = Date.now() - startTime;

                    // Remove progress bar
                    progressDiv.remove();

                    // Add summary at the top
                    const summary = createSummary(results, target, scanTime);
                    resultsDiv.insertBefore(summary, resultsDiv.firstChild);

                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color: #ff8a80; text-align: center;">Error during scan: ${error.message}</p>`;
                }
            });

            // Allow Enter key to trigger scan
            targetInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    scanButton.click();
                }
            });
        });
    </script>
</body>

</html>